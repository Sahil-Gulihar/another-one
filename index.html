<p>
  This example shows you the contents of the selected part of your display.
  Click the Start Capture button to begin.
</p>

<p>
  <button id="start">Start Capture</button>&nbsp;<button id="stop">
    Stop Capture
  </button>
</p>

<video id="video" autoplay playsinline></video>
<br />

<strong>Log:</strong>
<br />
<pre id="log"></pre>

<script>
  const videoElem = document.getElementById("video");
  const logElem = document.getElementById("log");
  const startElem = document.getElementById("start");
  const stopElem = document.getElementById("stop");

  let localStream;
  let peerConnection;
  const config = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

  const displayMediaOptions = {
    video: {
      displaySurface: "window",
    },
    audio: false,
  };

  // Set up WebSocket for signaling
  const signalingServerUrl = "ws://localhost:8080";
  const signalingSocket = new WebSocket(signalingServerUrl);

  signalingSocket.onmessage = async (message) => {
    let messageData;

    // If the data is a Blob, convert it to text
    if (message.data instanceof Blob) {
      messageData = await message.data.text();
    } else {
      messageData = message.data;
    }

    try {
      const data = JSON.parse(messageData);

      switch (data.type) {
        case "offer":
          handleOffer(data.offer);
          break;
        case "answer":
          handleAnswer(data.answer);
          break;
        case "ice-candidate":
          handleIceCandidate(data.candidate);
          break;
        default:
          console.error("Unknown message type:", data.type);
      }
    } catch (err) {
      console.error("Failed to parse message:", err, messageData);
    }
  };

  startElem.addEventListener(
    "click",
    () => {
      startCapture();
    },
    false
  );

  stopElem.addEventListener(
    "click",
    () => {
      stopCapture();
    },
    false
  );

  console.log = (msg) => (logElem.textContent += `${msg}\n`);
  console.error = (msg) => (logElem.textContent += `Error: ${msg}\n`);

  async function startCapture() {
    logElem.textContent = "";

    try {
      localStream = await navigator.mediaDevices.getDisplayMedia(
        displayMediaOptions
      );
      videoElem.srcObject = localStream;
      setupWebRTC();
      dumpOptionsInfo();
    } catch (err) {
      console.error(err);
    }
  }

  function stopCapture() {
    let tracks = videoElem.srcObject.getTracks();
    tracks.forEach((track) => track.stop());
    videoElem.srcObject = null;
    if (peerConnection) {
      peerConnection.close();
      peerConnection = null;
    }
  }

  function dumpOptionsInfo() {
    const videoTrack = videoElem.srcObject.getVideoTracks()[0];

    console.log("Track settings:");
    console.log(JSON.stringify(videoTrack.getSettings(), null, 2));
    console.log("Track constraints:");
    console.log(JSON.stringify(videoTrack.getConstraints(), null, 2));
  }

  function setupWebRTC() {
    peerConnection = new RTCPeerConnection(config);

    localStream.getTracks().forEach((track) => {
      peerConnection.addTrack(track, localStream);
    });

    peerConnection.onicecandidate = (event) => {
      if (event.candidate) {
        signalingSocket.send(
          JSON.stringify({
            type: "ice-candidate",
            candidate: event.candidate,
          })
        );
      }
    };

    peerConnection.oniceconnectionstatechange = () => {
      console.log("ICE state: " + peerConnection.iceConnectionState);
    };

    peerConnection.ontrack = (event) => {
      if (videoElem.srcObject !== event.streams[0]) {
        console.log("Received remote stream");
        videoElem.srcObject = event.streams[0];
      }
    };

    peerConnection
      .createOffer()
      .then((offer) => {
        return peerConnection.setLocalDescription(offer);
      })
      .then(() => {
        signalingSocket.send(
          JSON.stringify({
            type: "offer",
            offer: peerConnection.localDescription,
          })
        );
      })
      .catch((error) => {
        console.error("Failed to create offer: " + error);
      });
  }

  function handleOffer(offer) {
    alert("handleOffer");
    peerConnection = new RTCPeerConnection(config);
    peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

    peerConnection.onicecandidate = (event) => {
      if (event.candidate) {
        signalingSocket.send(
          JSON.stringify({
            type: "ice-candidate",
            candidate: event.candidate,
          })
        );
      }
    };

    peerConnection.ontrack = (event) => {
      if (videoElem.srcObject !== event.streams[0]) {
        console.log("Received remote stream");
        videoElem.srcObject = event.streams[0];
      }
    };

    peerConnection
      .createAnswer()
      .then((answer) => {
        return peerConnection.setLocalDescription(answer);
      })
      .then(() => {
        signalingSocket.send(
          JSON.stringify({
            type: "answer",
            answer: peerConnection.localDescription,
          })
        );
      })
      .catch((error) => {
        console.error("Failed to create answer: " + error);
      });
  }

  function handleAnswer(answer) {
    alert("handleAnswer");
    peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
  }

  function handleIceCandidate(candidate) {
    alert("handleIceCandidate");
    peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
  }
</script>
